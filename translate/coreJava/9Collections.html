<!DOCTYPE HTML>
<html xml:lang="en">
	<head>
		<title>9 集合</title>
		<link rel="stylesheet" type="text/css" href="../../../bootstrap.css" />
    		<link rel="stylesheet" type="text/css" href="base.css" />
		<base target="_blank" />
	</head>
	<body>
		<div id="container">
			<h3>9 集合</h3>
			<ol type='I'>
			<li>
			<p>
			<h4>Intro</h4>
			选择什么数据结构将会对你的方法的实现和性能产生重大影响。
			你是否需要在大量有序条目中快速搜索？你是否需要对有序序列作插入和删除元素?
			是否需要在键值(key-value)间建立联结。<br />
			本章教你使用java标准库以完成传统数据构造。与大学数据结构课程不同，
			这里跨过原理，直接如何使用。
			<h4>9.1 接口和实现分离</h4>
			同现代数据结构库一样，Java集合库分离接口和实现。考察queue。
			<br />队列<a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">(queue-wiki)</a>
				规定：添加元素到尾部，删除头部元素，以及
			得到队列中元素个数。当需要收集对象并按照“先进先出”操作时，使用队列。<br />
			public interface Queue&lt;E&gt; // a simplified form of the interface in the standard library<br/>
			{<br/>
				void add(E element);<br/>
				E remove();<br/>
				int size();<br/>
			}<br/>
			<br />接口不会告诉你任何关于内部实现的信息。实际上，有两种常规的队列实现:循环数组
			实现或者链表实现。
			<br />每个实现类都要实现Queue接口。<br />
			一旦集合被构造，你不需要知道它的具体实现。使用接口类型来引用集合。<br />
			Queue&lt;Customer&gt; expressLane = new CircularArrayQueue&lt;&gt;(100);<br />
			expressLane.add(new Customer("Harry"));<br />
			使用这种方法，如果你改变注意，你可以很方便的切换实现。只需要在构造器调用
			处修改即可。如果你想改用LinkedListQueue，<br />
			Queue&lt;Customer&gt; expressLane = new LinkedListQueue&lt;&gt;(100);<br />
			expressLane.add(new Customer("Harry"));<br />
			为什么你会选择一种实现而不是另一种？接口没有告诉你某种实现的效率如何。循环
			数组某种程度上比链表实现要高效些，所以经常被使用。然而，也有其他代价。<br />
			循环数组是有限的——它有固定容量。如果你不清楚集合元素数量的最大值，还是选择链表
			实现。<br />
			在你学习API文档时，你可能碰到AbstractQueue。它是队列的部分实现，更易于扩展。
				
			<h4>9.1.2 Collection 接口</h4>
			Java库集合类的基础接口是Collection。它有两个根本方法：<br/>
			public interface Collection&lt;E&gt; <br />
			{ <br />
			boolean add(E element);<br />
			Iterator&lt;E&gt; iterator();<br />
			. . .<br />
			}<br />
			除了这两个方法外还有其他方法，稍后再谈。<br />
			add方法如其意。如果实际上集合变化了则返回true，否则false。例如
			试图向set中添加一个对象，如果此对象已经存在，add对set无影响，因为
			sets不允许重复对象。（？怎样判定对象已经存在？难道每个对象不是独一无二的吗？）
			<br >iterator方法（迭代器）返回一个实现了Iterator接口的对象。你可以使用这个迭代器
			对象（iterator object）逐一遍历集合元素，如下节讨论的。
				
			<h4>9.1.3 迭代器(Iterators)</h4>
			Iterator接口有4个方法：<br/>
			public interface Iterator&lt;E&gt; <br/>
			{<br/>
				E next();<br/>
				boolean hasNext();<br/>
				void remove();<br/>
				default void forEachRemaining(Consumer&lt;? super E&gt; action);<br/>
			}<br/>
			不断调用next方法，你就可以注意访问集合中的元素。如果到达集合的末尾，next
			方法会抛出NoSuchElementException。因此，在next前需要hasNext方法来检测还有没有
			元素。按照如下代码迭代集合所有元素：<br/>
			Collection&lt;String&gt; c = . . .;<br/>
			Iterator&lt;String&gt; iter = c.iterator();<br/>
			while (iter.hasNext())<br/>
			{<br/>
			String element = iter.next();<br/>
			do something with element<br/>
			}<br/>
			更简洁的，你可以使用for each 来替代while循环:<br/>
			for (String element : c)<br/>
			{<br/>
			do something with element<br/>
			}<br/>
			编译器将for each循环转化为处理迭代器的普通循环。<br/>
			for each对实现了Iterable接口的任何对象都有效。Collection接口继承自Iterable。因此，
			你可以使用for each 迭代标准库的任意集合。<br/>
			SE8,你甚至可以...<br/>
			元素被访问顺序取决于集合类型。如果是ArrayList，迭代器从index为0开始，并依次
			每步加1往上。如果是HashSet，则顺序随机，你可以迭代所有元素，但对于顺序你无法
			事先确知。有些情况下元素顺序是不重要的，如计算总和或匹配元素时。<br/>
			java标准库对迭代器的实现有个重要的不同点（如与c++相比）。java中，迭代(lookup)
			与索引改变(position change)是同步的，你只能使用next方法向后索引元素，同时往前进。
			<br/>
			remove方法删除你上一次调用next返回的元素。删除集合第一个元素的代码如下：<br/>
			Iterator&lt;String&gt; it = c.iterator();<br/>
			it.next(); // skip over the first element<br/>
			it.remove(); // now remove it<br/>
			<h4>9.1.4 处理泛型的通用方法(Generic Utility Methods)</h4>
			Collection和Iterator接口是泛型的（Generic），这意味着你可以写一个通用方法来
			操作任意类型的集合。下面是一个检测给定集合是否包含给定元素的通用方法：<br/>
			public static &lt;E&gt; boolean contains(Collection&lt;E&gt c, Object obj)<br/>
			{<br/>
			for (E element : c)<br/>
			&nbsp;if (element.equals(obj))<br/>
			&nbsp;&nbsp;return true;<br/>
			return false;<br/>
			}<br/>
			java库的设计者认为像这样的通用方法是如此有用，所以java库应该包含这些方法。
			如此，应用程序员就不必自己再造轮子了。（上面的contains方法就是其中之一）<br/>
			实际上，Collection接口声明了（declare）很多有用的方法，它的实现类都必须实现的。
			其中有<br/>
			int size()<br/>
			boolean isEmpty()<br/>
			boolean contains(Object obj)<br/>
			boolean containsAll(Collection&lt;?&gt; c)<br/>
			boolean equals(Object other)<br/>
			boolean addAll(Collection&lt;? extends E&gt; from)<br/>
			boolean remove(Object obj)<br/>
			boolean removeAll(Collection&lt;?&gt; c)<br/>
			void clear()<br/>
			boolean retainAll(Collection&lt;?&gt; c)<br/>
			Object[] toArray()<br/>
			&lt;T&gt; T[] toArray(T[] arrayToFill)<br/>
			这些方法大都无需解释(self-explanatory);如果需要，请查看API。<br/>
			当然，每次都要实现所有这些方法很麻烦。为了让实现更容易，java库提供了
			AbstractCollection，除了size方法和iterator，其他方法都被实现了。<br/>
			这样，具体的集合实现类直接继承AbstractCollection即可。你需要实现iterator方法，
			但contains已经被超类实现。然而，你如果不满意，可以覆盖它。<br/>
			<h4>9.1.5 Collections框架中的接口</h4>	
			</p>
			</li>
			</ol>
		</div>
	</body>
</html>
